[{"content":" #背景我们想求解的是这样一类问题：固定模数 $p^e$，多次查询 $\\binom nm \\bmod p^e$，默认一般情况下 $p \u0026gt; e$。\n当 $n$ 和 $m$ 比较小的时候，预处理阶乘数组可以很好地解决问题。因此我们主要关心的是当 $n$ 和 $m$ 很大（比如 $10^{18}$ 量级）时该问题是否有很好的解法。下面介绍该问题的一种方向。\n我们很容易 $\\mathcal O(\\log n)$ 计算出 $n!$ 中含有的 $p$ 因子数量 $(n!)_p = \\sum _{k\\geq 1} \\lfloor\\frac{n}{p^k}\\rfloor$。那么有\n$$ \\dbinom nm = \\dfrac{n!}{m!(n - m)!}=\\dfrac{\\dfrac{n!}{p^{(n!)_p}}}{\\dfrac{m!}{p^{(m!)_p}}\\dfrac{(n - m)!}{p^{((n - m)!)_p}}}p^{(n!)_p - (m!)_p - ((n - m)!)_p} $$\n问题还是落在了计算 $\\dfrac{n!}{p^{(n!)_ p}}$ 上。如果我们能够计算 $\\displaystyle F(n) = \\prod_{i=1, i\\perp p}^n i$，那么仍然可以得到：\n$$ \\dfrac{n!}{p^{(n!)p}} = \\prod{k\\geq 0}F(\\lfloor \\dfrac{n}{p^k}\\rfloor) $$\n因此这个方向的核心在于计算 $F$，如果我们能够以 $\\mathcal O(t)$ 单次的时间复杂度回答 $F$，那么问题就可以以 $\\mathcal O(t \\log n)$ 的时间复杂度被解决。\n下面将介绍几种常见的计算 $F$ 的方法。\n#ExLucas$$ \\begin{aligned} F(n) \u0026amp;= \\prod_{i=1, i\\perp p}^n i\\ \u0026amp;\\equiv \\left(\\prod_{i=1, i\\perp p}^{p^e} i\\right)^{(n / p^e)}\\prod_{i=1,i\\perp p}^{n \\bmod p^e}i \\end{aligned} $$\n枚举就好了！时间复杂度 $\\mathcal O(p^e)$。\n#少项式平移相关题目：「2018 集训队互测 Day 1」完美的集合，那题是模 $5^{23}$。\n考虑设计多项式 $\\displaystyle G_n(x) = \\prod_{i=1, i\\perp p}^n(x + i)$，我们要求的 $F(n)$ 即为 $G_n(0)$。\n考虑从 $G_p(x)$ 开始，倍增得到 $G_{\\lfloor \\frac{n}{p} \\rfloor p}(x)$，再暴力乘 $n \\bmod p$ 个 $(x + i)$。\n若要倍增，则需要解决 $G_{ap} \\to G_{2ap}$ 和 $G_{ap} \\to G_{(a + 1)p}$ 的问题。\n$G_{2ap}(x) = G_{ap}(x)\\times G_{ap}(x + ap)$，后一部分可以二项式定理暴力展开，原因下面会提到； $G_{(a + 1)p}(x) = G_{ap}(x) \\times G_p(x + ap)$，同上。 注意到，$x$ 始终是 $p$ 的倍数，这意味着在 $\\bmod \\ p^e$ 意义下，我们只需要保留前 $e$ 项进行运算，这也保证了我们可以暴力展开、暴力乘法等。\n每次 $ap \\to 2ap$ 或 $ap \\to (a + 1)p$ 所需的时间是 $\\mathcal O(e^2)$，故回答 $F$ 的时间复杂度为 $\\mathcal O(e^2\\log n)$。\n注意我们要预处理 $G_0 \\sim G_p$ 的系数，不仅为了求一开始的 $G_p$，还为了最后的暴力乘不用真的乘 $n \\bmod p = \\mathcal O(p)$ 次，而是直接乘 $G_{n \\bmod p}(x + \\lfloor \\frac np\\rfloor p)$。预处理的时间复杂度是 $\\mathcal O(pe)$ 的。\n#min_25 binom考虑让 $n$ 对 $p$ 做带余除法，假设得到 $n = up + v$。我们有：\n$$ \\begin{aligned} F(n) \u0026amp;= \\left (\\prod_{i=0}^{u-1}\\prod_{j=1}^{p - 1}(ip + j)\\right)\\prod_{j=1}^v(up + j)\\ \u0026amp;= \\left(\\prod_{i=0}^{u - 1}\\sum_{k=0}^{p-1}(ip)^k\\begin{bmatrix}p\\k + 1\\end{bmatrix}\\right)\\left(\\sum_{k=0}^v(up)^k\\begin{bmatrix}v + 1\\k + 1\\end{bmatrix}\\right) \\end{aligned} $$\n上面是一个上升幂转普通幂。注意到 $(ip)^k$ 和 $(up)^k$ 当 $k \\geq e$ 时模意义下直接变成 $0$ 了，故我们可以进一步优化：\n$$ \\begin{aligned} F(n) \u0026amp;\\equiv \\left(\\prod_{i=0}^{u - 1}\\sum_{k=0}^{e-1}(ip)^k\\begin{bmatrix}p\\k + 1\\end{bmatrix}\\right)\\left(\\sum_{k=0}^{e - 1}(up)^k\\begin{bmatrix}v + 1\\k + 1\\end{bmatrix}\\right)\\ \u0026amp;= \\begin{bmatrix}p\\1\\end{bmatrix}^u\\left(\\prod_{i=0}^{u - 1}\\sum_{k=0}^{e - 1}(ip)^k\\dfrac{\\begin{bmatrix}p\\k + 1\\end{bmatrix}}{\\begin{bmatrix}p\\1\\end{bmatrix}}\\right)\\left(\\sum_{k=0}^{e - 1}(up)^k\\begin{bmatrix}v + 1\\k + 1\\end{bmatrix}\\right)\\ \u0026amp;= \\begin{bmatrix}p\\1\\end{bmatrix}^uf_e(p, u)\\left(\\sum_{k=0}^{e - 1}(up)^k\\begin{bmatrix}v + 1\\k + 1\\end{bmatrix}\\right) \\end{aligned} $$\n让我们用稍微跳脱的眼光看待 $\\begin{bmatrix} p \\\\ 1 \\end{bmatrix}^u$，我们把这 $\\log$ 次求解 $F$ 中的这玩意提出来放一起。实际上就是在最终回答 $\\dfrac{n!}{p^{(n!)_ p}}$ 的时候用 $\\mathcal O(\\log n)$ 快速幂算出 $\\begin{bmatrix}p\\\\1\\end{bmatrix}^{(n!)_p}$ 给答案乘上，这显然不会成为瓶颈。\n再说后面的 $\\displaystyle \\left(\\sum_ {k=0}^{e - 1}(up)^k\\begin{bmatrix}v + 1\\\\k + 1\\end{bmatrix}\\right)$，这个可以先 $\\mathcal O(pe)$ 预处理出所有 $i \\in [0, p], j \\in [0, e]$ 的 $\\begin{bmatrix}i\\\\j\\end{bmatrix}$，然后每次问 $F$ 的时候就只需要 $\\mathcal O(e)$ 累乘了。\n因此，我们最大的问题在于计算 $f_e(p, u)$，而且看起来似乎没有任何头绪。但出人意料的是，$f_e(p, u)$ 的性质很好！\n事实上，$f_e(p, u)$ 是关于 $u$ 的 $(2e - 2)$ 次多项式！\n证明.\n首先明确方向：为了确定这样的多元多项式关于积式枚举范围的次数，我们最好取个 $\\ln$，求解关于和式枚举范围的次数（一般不是很困难），然后再 $\\exp$ 回去。\n懒得写那个系数了，把它简记为 $a_k$，那么 $f_e(p, u)$ 形如\n$$ f_e(p, u) = \\prod_{i=0}^{u - 1}\\sum_{k=0}^{e - 1}a_k(ip)^k $$\n注意到我们在上面推式子时已经通过除以 $\\begin{bmatrix}p\\\\1\\end{bmatrix}$ 保证了 $a_0 = 1$，那么就可以两边取 $\\ln$ 了：\n$$ \\begin{aligned} \\ln f_e(p, u) \u0026amp;= \\sum_{i=0}^u\\ln(1 + \\sum_{k=1}^{e - 1}a_k(ip)^k)\\ \u0026amp;= \\sum_{i=0}^u\\sum_{k \\geq 1}b_k(ip)^k\\ \u0026amp;= \\sum_{k \\geq 1}b_k p^k \\sum_{i=0}^u i^k\\ \u0026amp;= \\sum_{k \\geq 1}b_k s_k(u) p^k \\end{aligned} $$\n那么我们可以 $\\exp$ 回去了。\n$$ \\begin{aligned} f_e(p, u) \u0026amp;= \\exp(\\sum_{k \\geq 1}b_ks_k(u)p^k)\\ \u0026amp;= \\sum_{i\\geq 0} \\dfrac{(\\sum_{k\\geq1}b_ks_k(u)p^k)^i}{i!}\\ \\end{aligned} $$\n我们现在要分析 $f_e(p, u)$ 中 $p^k$ 项所对 $u$ 的最高次项系数。假设其由 $\\ln f_e(p, u)$ 中的 $p^{i_1}, p^{i_2}, \\cdots, p^{i_j}$ 这 $j$ 项相乘贡献，那么含有 $u$ 的部分其实是 $\\prod_{q=1}^j s_{i_q}(u)$。经典结论是 $s_x(u)$ 是关于 $u$ 的 $x + 1$ 次多项式，因此此时 $u$ 的次数是 $\\sum (i_q + 1) = \\sum i_q + j = k + j$，所以 $j$ 越大，贡献中的 $u$ 的次数越多。$j$ 最大时显然是 $j = k$ 且 $i_1 = i_2 = \\cdots = i_j = 1$ 时，此时 $u$ 的次数为 $j + k = 2k$。因此，我们知道：$p^k$ 所对 $u$ 的最高次项系数为 $2k$。\n不要忘了题目对 $p^e$ 取模的条件。因此我们仍然可以把 $k \\geq e$ 的项略去，此时整个多项式即为关于 $u$ 的 $(2e - 2)$ 次多项式。\n$\\mathbf{\\square.}$\n因此，根据已经预处理好的第一类斯特林数，可以 $\\mathcal O(e^2)$ 预处理出 $f_e(p, 0), f_e(p, 1), \\cdots, f_e(p, 2e-2)$。然后即可在回答询问时 $\\mathcal O(e)$ 拉插出 $f_e(p, u)$。\n综上，使用这种方法求解 $F$，可以做到 $\\mathcal O(pe)$ 预处理，$\\mathcal O(e)$ 回答 $F$。\n#ex 少项式平移考虑平衡『少项式平移』中预处理和询问的复杂度。\n具体来说，我们可以直接对 $0 \\leq i \\leq 7, 1 \\leq j \u0026lt; 256$ 预处理 $G_{256^i \\cdot j \\cdot p}$，每次回答拿出要用的多项式以后，就不需要用二项式定理平移它们并乘起来了。可以分别算出需要代入的 $x$ 并求点值，最后乘起来。回答 $F$ 的时间复杂度优化至 $\\mathcal O(e \\log_{256} n)$。\n在 OI 常见的数据范围中（如 $n, k \\leq 10^{18}$），这个 $\\log_{256} n$ 实际上是快于 min_25 binom 做法中隐含的常数的。\n作者用 Project Euler #242: Odd Triplets 测试了『min_25 binom』和『ex 少项式平移』的效率，在本地的最大运行速度分别为 1.8s 和 0.9s。\n#代码这是一份可以通过 Project Euler #242: Odd Triplets 的代码。\n#include \u0026lt;bits/extc++.h\u0026gt; #define ALL(v) begin(v), end(v) using i64 = int64_t; using i128 = __int128; void Exgcd(i64 a, i64 b, i128 \u0026amp;x, i128 \u0026amp;y) { if (!b) return x = 1, void(y = 0); Exgcd(b, a % b, y, x), y -= (a / b) * x; } auto Inv(i64 x, i64 p) -\u0026gt; i64 { i128 a, b; return Exgcd(x, p, a, b), (a % p + p) % p; } namespace binomial { const int kMaxE = 63, kMaxP = 1E5 + 5; int p, e; i64 pe; void Add(i64 \u0026amp;x, i64 y) { if ((x += y) \u0026gt;= pe) x -= pe; } auto Sum(i64 x, i64 y) { return Add(x, y), x; } __gnu_pbds::cc_hash_table\u0026lt;i64, i64\u0026gt; memo; std::array\u0026lt;i64, kMaxE\u0026gt; power{1}; std::array\u0026lt;std::array\u0026lt;i64, kMaxE\u0026gt;, kMaxE\u0026gt; binom; std::array\u0026lt;std::array\u0026lt;i64, kMaxE\u0026gt;, kMaxP\u0026gt; g; std::array\u0026lt;std::array\u0026lt;i64, kMaxE\u0026gt;, kMaxE\u0026gt; gp; std::array\u0026lt;std::array\u0026lt;std::array\u0026lt;i64, kMaxE\u0026gt;, 256\u0026gt;, 8\u0026gt; gpp; void SetMod(int p, int e) { g[0].fill(0), g[0][0] = 1, binomial::p = p, binomial::e = e; for (int i = 1; i \u0026lt;= e; ++i) power[i] = power[i - 1] * p; pe = power[e], memo.clear(); for (int i = 0; i \u0026lt; kMaxE; ++i) binom[i][0] = 1; for (int i = 1; i \u0026lt; kMaxE; ++i) { for (int j = 1; j \u0026lt;= i; ++j) { binom[i][j] = Sum(binom[i - 1][j], binom[i - 1][j - 1]); } } for (int i = 1; i \u0026lt; p; ++i) { for (int j = 0; j \u0026lt; e; ++j) g[i][j] = i128{g[i - 1][j]} * i % pe; for (int j = 1; j \u0026lt; e; ++j) Add(g[i][j], g[i - 1][j - 1]); } gp[0] = g[p] = g[p - 1]; for (int i = 1; i \u0026lt; kMaxE; ++i) { std::vector\u0026lt;i64\u0026gt; coef(e); i64 a = (i128{p} \u0026lt;\u0026lt; (i - 1)) % pe; for (int j = 0; j \u0026lt; e; ++j) { i64 m = 1; for (int k = j; k \u0026lt; e; ++k) { Add(coef[j], i128{m} * binom[k][j] % pe * gp[i - 1][k] % pe); m = i128{m} * a % pe; } } for (int j = 0; j \u0026lt; e; ++j) { gp[i][j] = 0; for (int k = 0; k \u0026lt;= j; ++k) { Add(gp[i][j], i128{gp[i - 1][k]} * coef[j - k] % pe); } } } for (int i = 0; i \u0026lt; 8; ++i) { gpp[i][1] = gp[i \u0026lt;\u0026lt; 3]; for (int j = 2; j \u0026lt; 256; ++j) { i64 a = (i128{p} \u0026lt;\u0026lt; (i \u0026lt;\u0026lt; 3)) % pe * (j - 1) % pe; std::vector\u0026lt;i64\u0026gt; coef(e); for (int x = 0; x \u0026lt; e; ++x) { i64 m = 1; for (int y = x; y \u0026lt; e; ++y) { Add(coef[x], i128{m} * binom[y][x] % pe * gpp[i][1][y] % pe); m = i128{m} * a % pe; } } for (int x = 0; x \u0026lt; e; ++x) { gpp[i][j][x] = 0; for (int y = 0; y \u0026lt;= x; ++y) { Add(gpp[i][j][x], i128{gpp[i][j - 1][y]} * coef[x - y] % pe); } } } } } auto F(i64 n) { if (memo.find(n) != end(memo)) return memo[n]; i64 ori_n = n, l = 0, v = 1; int r = n % p; n /= p; for (int i = 0; n; n \u0026gt;\u0026gt;= 8, ++i) { int u = n \u0026amp; 255; if (u) { i64 c = 0, m = 1; for (int j = 0; j \u0026lt; e; ++j) { Add(c, i128{m} * gpp[i][u][j] % pe), m = i128{m} * l % pe; } l += i64{p * u} \u0026lt;\u0026lt; (i \u0026lt;\u0026lt; 3), v = i128{v} * c % pe; } } i64 c = 0, m = 1; for (int j = 0; j \u0026lt; e; ++j) { Add(c, i128{m} * g[r][j] % pe), m = i128{m} * l % pe; } return memo[ori_n] = i128{v} * c % pe; } auto CountFactor(i64 n) { i64 cnt = 0; for (; n /= p;) cnt += n; return cnt; } auto Reduce(i64 n) { i64 mul = 1; for (; n; n /= p) mul = i128{mul} * F(n) % pe; return mul; } auto Binom(i64 n, i64 m) -\u0026gt; i64 { if (n \u0026lt; 0 || m \u0026lt; 0 || n \u0026lt; m) return 0; i64 exp = CountFactor(n) - CountFactor(m) - CountFactor(n - m); if (exp \u0026gt;= e) return 0; i64 rn = Reduce(n), rm = Reduce(m), rnm = Reduce(n - m); return i128{rn} * Inv(rm, pe) % pe * Inv(rnm, pe) % pe * power[exp] % pe; } } // namespace binomial i64 m, r, n, k, M; std::vector\u0026lt;std::pair\u0026lt;i64, int\u0026gt;\u0026gt; decom; void Decom(i64 m) { for (int i = 2; i64{i} * i \u0026lt;= m; ++i) { if (m % i) continue; decom.emplace_back(i, 0); while (!(m % i)) ++decom.back().second, m /= i; } if (m \u0026gt; 1) decom.emplace_back(m, 1); } std::map\u0026lt;i64, i64\u0026gt; phi, mu; void Dfs(int u, i64 v, i64 p, i64 m) { if (u == decom.size()) return phi[v] = p, void(mu[v] = m); Dfs(u + 1, v, p, m), p *= (decom[u].first - 1), m = -m; for (int i = 1; i \u0026lt;= decom[u].second; ++i) { v *= decom[u].first; Dfs(u + 1, v, p, m); p *= decom[u].first, m = 0; } } auto main() -\u0026gt; int { std::ios::sync_with_stdio(false); std::cin.tie(nullptr), std::cout.tie(nullptr); std::cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; r \u0026gt;\u0026gt; n \u0026gt;\u0026gt; k \u0026gt;\u0026gt; M; i64 ep = ((i128{k + 1} * k / 2 - r) % m + m) % m; Decom(m), Dfs(0, 1, 1, 1); i64 a = 0, b = 1; for (int p = 2; p \u0026lt;= 1E5; ++p) { if (M % p) continue; int e = 0; while (!(M % p)) ++e, M /= p; binomial::SetMod(p, e); i64 ans = 0; for (auto [d, phi] : ::phi) { if (n % d - k % d) continue; i64 g = std::__gcd(d, ep), mul; mul = (phi / ::phi[d / g]) * mu[d / g] % binomial::pe; mul = i128{mul} * binomial::Binom(n / d, k / d) % binomial::pe; (ans += mul) %= binomial::pe; } i128 k1, k2; Exgcd(b, binomial::pe, k1, k2); a = (a + i128{ans - a} * (k1 % binomial::pe) * b) % (b * binomial::pe); b *= binomial::pe; if (a \u0026lt; 0) a += b; } std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } #Reference Binomial Modulo Prime Power，本文 min_25 binom 相关部分是对这篇文章的翻译补充。 ","id":0,"path":"/misc/binom-mod-pe/","title":"大组合数模小质数幂"},{"content":" #思想通过对限制变形，给圆心 $(x, y)$ 赋合适的估价（与半径 $r$ 相关），并证明：固定 $x$ 时，估价是凸的；对所有 $x$，最优的 $y$ 的估价也是凸的。从而外层三分 $x$，内层三分 $y$ 即可 $\\mathcal O(f(n)\\log^2(\\dfrac{1}{\\epsilon}))$ 解决。\n具体的分析在各种问题中是不一样的，但方向类似，下面用几道题简单说明一下。\n#合法圆覆盖 给定平面上的 $n$ 个黑点 $(a_i, b_i)$，$m$ 个白点 $(c_i, d_i)$，找到一个圆覆盖所有黑点并且不覆盖任何白点。\n设答案圆为 $(x, y, r)$，那么 $(a_i, b_i)$ 被覆盖等价于：\n$$ (x - a_i)^2 + (y - b_i)^2 \\leq r^2 $$\n也就是，\n$$ 2a_ix + 2b_iy + (r^2 -x^2 - y^2) - a_i^2 - b_i^2 \\geq 0 $$\n相当于强制点 $(x, y, r^2 - x^2 - y^2)$ 在某半空间内。$(c_i, d_i)$ 不被覆盖，式子也是类似的，同样是限制该点在某半空间内。\n从而，合法的 $(x, y, r^2 - x^2 - y^2)$ 集合是由 $n + m$ 个半空间相交得到的，从而是一个三维凸包。\n我们令固定 $(x, y)$ 后的估价为合法的 $r^2 - x^2 - y^2$ 的范围（显然是一个区间）的长度。此时固定 $x$ 后，$(y, r^2 - x^2 - y^2)$ 是二维凸包，内层三分凸性显然。对所有的 $x = x_1$，其最优估价也显然是凸的（可以反证，不是凸的会导出原集合不是三维凸包），从而外层的三分也是对的。\n二分出最大的范围后，如果该范围是非空的，我们就得到了一组合法解，否则直接报告无解即可。\n#最小圆覆盖 给定平面上的 $n$ 个点，求一个最小的圆覆盖所有点。\n我们仍然可以沿用上一部分的分析，但需要注意的是，我们的估价为 $\\min (r^2 - x^2 - y^2)$，这实际上和题目所要最小化的目标 $r$ 是不一样的。\n但好在，我们的估价实际上是 $\\min z$，所以我们只关心这个三维凸包的下凸壳。而对所有点 $z \\gets z + x^2 + y^2$ 这个操作，由于 $f(x) = x^2$ 也是下凸的，那么原先的下凸壳在这次操作后仍然能够保持凸性。\n因此，我们把估价修改为 $\\min r$ 即可得到正确的做法。\n#最大被覆盖圆 给定平面上 $n$ 个圆，找到一个最大的圆被这 $n$ 个圆的交覆盖。\n假设给定的圆是 $(a_i, b_i, c_i)$，答案圆是 $(x, y, r)$，我们需要满足：\n$r \\leq c_i$（这一部分很重要，否则变形不充要，我们也难以得到下面的优美结论） $(a_i - x)^2 + (b_i - y)^2 \\leq (c_i - r)^2$ 这实际上是对于 $(x, y, r)$ 这个点，钦定它在某圆锥内。\n（注意由于 $r \\leq c_i$，实际上合法集合取的是下面那个圆锥，而非图中全部的红色区域）\n圆锥是凸的，从而考虑所有限制后，合法的 $(x, y, r)$ 是三维凸包。\n这里的估价函数就是 $\\max r$，因此内外层的凸性是有的（证明同“合法圆覆盖”），从而三分套三分能够正确地求出最大的合法圆。\n","id":1,"path":"/misc/circ-cover/","title":"一类三分套三分在圆覆盖问题中的应用"},{"content":"搬运自 Pattern Avoidance in Reverse Double Lists。\n#定义RDL（Reverse Double List） 是把一个排列的反串拼接在它的后面得到的结构。\n具体来说，记长为 $2n$ 的 RDL 构成的集合为 $\\mathcal{R}_n$，那么有 $\\mathcal R_n = \\{ \\pi\\pi^{\\textsf{R}}\\mid\\pi \\in \\mathcal S_n \\}$，其中 $\\mathcal S_n$ 是所有 $n$ 阶排列构成的集合。 避免 Pattern 的 RDL 计数是这样一个问题：\n给定我们称之为 Pattern 的一个排列 $\\rho$。 考虑满足如下条件的 $n$ 阶 RDL： 不存在大小为 $\\lvert \\rho \\rvert$ 的子序列，满足其中元素的相对大小顺序和 $\\rho$ 相等。 满足该条件的 $n$ 阶 RDL 集合被记作 $\\mathcal R_n(\\rho)$，我们要求的即 $\\lvert \\mathcal R_n(\\rho)\\rvert$。 事实上，对于 $\\lvert \\rho \\rvert \\leq 4$ 的情形，我们有足够快速简单的方法计算 $\\lvert \\mathcal R_n(\\rho)\\rvert$。\n由于篇幅有限，下文中的结论并不会给出证明，详细证明可见原论文。\n#$\\lvert\\rho\\rvert \\leq 3$$$ \\begin{aligned} \u0026amp;\\lvert\\mathcal R_n(\\langle1\\rangle)\\rvert = 0\\ \u0026amp;\\lvert\\mathcal R_n(\\langle1, 2\\rangle)\\rvert = \\lvert\\mathcal R_n(\\langle2, 1\\rangle)\\rvert = \\begin{cases} 1 \u0026amp; n = 1\\ 0 \u0026amp; n \\geq 2 \\end{cases}\\ \u0026amp;\\lvert\\mathcal R_n(\\langle1, 2, 3\\rangle)\\rvert = \\lvert\\mathcal R_n(\\langle3, 2, 1\\rangle)\\rvert = \\begin{cases} 1 \u0026amp; n = 1\\ 2 \u0026amp; n = 2, 3\\ 0 \u0026amp; n \\geq 4 \\end{cases}\\ \u0026amp;\\lvert\\mathcal R_n(\\langle1, 3, 2\\rangle)\\rvert = \\lvert\\mathcal R_n(\\langle2, 3, 1\\rangle)\\rvert= \\lvert\\mathcal R_n(\\langle3, 1, 2\\rangle)\\rvert= \\lvert\\mathcal R_n(\\langle2, 1, 3\\rangle)\\rvert = \\begin{cases} 1 \u0026amp; n = 1\\ 2 \u0026amp; n \\geq 2 \\end{cases} \\end{aligned} $$\n这一部分的 $\\lvert \\mathcal R_n(\\rho)\\rvert$ 都可以被 $\\mathcal O(1)$ 计算。\n#$\\lvert \\rho \\rvert = 4$这一部分当 $n$ 较小时，$\\lvert\\mathcal R_n(\\rho)\\rvert$ 并没有很好的性质，不过我们可以用 $\\mathcal O(n! \\cdot \\text{poly}(n))$ 的暴力求解。\n下表中的式子都是 $n$ 较大时成立的（式子后面标注了成立的范围）。\nPattern $\\rho$ $\\lvert\\mathcal R_n(\\rho)\\rvert=$ $\\langle1,2,3,4\\rangle, \\langle4,3,2,1\\rangle$ $0\\qquad(n \\geq 7)$ $\\langle1,2,4,3\\rangle, \\langle2,1,3,4\\rangle, \\langle3,4,2,1\\rangle, \\langle4,3,1,2\\rangle$ $\\dfrac{n^3}3-\\dfrac{7n}3+4\\qquad(n \\geq 3)$ $\\langle1,3,2,4\\rangle, \\langle4,2,3,1\\rangle, \\langle2,1,4,3\\rangle, \\langle3,4,1,2\\rangle$ $2\\lvert\\mathcal R_{n−1}(\\rho)\\rvert + 4\\qquad(n \\geq 4)$ $\\langle1,4,2,3\\rangle, \\langle2,3,1,4\\rangle, \\langle3,2,4,1\\rangle, \\langle4,1,3,2\\rangle$ $2\\lvert\\mathcal R_{n−1}(\\rho)\\rvert + \\lvert\\mathcal R_{n−3}(\\rho)\\rvert + 2\\qquad(n \\geq 5)$ $\\langle1,4,3,2\\rangle, \\langle2,3,4,1\\rangle, \\langle3,2,1,4\\rangle, \\langle4,1,2,3\\rangle$ $2\\lvert\\mathcal R_{n−1}(\\rho)\\rvert + \\lvert\\mathcal R_{n−2}(\\rho)\\rvert\\qquad(n \\geq 5)$ $\\langle1,3,4,2\\rangle, \\langle2,4,3,1\\rangle, \\langle3,1,2,4\\rangle, \\langle4,2,1,3\\rangle$ $2\\lvert\\mathcal R_{n−1}(\\rho)\\rvert + \\lvert\\mathcal R_{n−2}(\\rho)\\rvert + 2\\qquad(n \\geq 4)$ $\\langle2,4,1,3\\rangle, \\langle3,1,4,2\\rangle$ $2\\lvert\\mathcal R_{n−1}(\\rho)\\rvert + 2\\lvert\\mathcal R_{n−2}(\\rho)\\rvert\\qquad(n \\geq 3)$ 对于第一、二行的式子，它们已经是封闭的形式了，我们可以直接 $\\mathcal O(1)$ 计算。\n其余的式子都是低阶线性递推，可以使用矩阵快速幂 $\\mathcal O(\\log n)$ 计算。\n#总结综上，对于所有的 $\\lvert \\rho \\rvert \\leq 4$，我们都可以以 $\\mathcal O(1)$ 或 $\\mathcal O(\\log n)$ 的时间复杂度计算 $\\lvert\\mathcal R_n(\\rho)\\rvert$。\n实际使用中，上面的式子不需要记住，只需要把 $n$ 较小的表打出来，去除前面不满足式子的 $\\mathcal O(1)$ 项，再作差分或高消系数得到式子即可。注意高消时要考虑这个递推式有常数项。\n","id":2,"path":"/misc/avoid-pattern-rdl/","title":"避免 Pattern 的 RDL 计数"},{"content":"","id":3,"path":"/categories/","title":"Categories"},{"content":"这里是一些杂文。\n","id":4,"path":"/misc/","title":"Misc"},{"content":"","id":5,"path":"/","title":"Reliauk"},{"content":"","id":6,"path":"/tags/","title":"Tags"}]